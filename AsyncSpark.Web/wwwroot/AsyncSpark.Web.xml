<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AsyncSpark.Web</name>
    </assembly>
    <members>
        <member name="T:AsyncSpark.Web.Controllers.Api.BaseApiController">
            <summary>
            Base for all Api Controllers in this project
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.BaseApiController.#ctor(Microsoft.Extensions.Caching.Memory.IMemoryCache)">
            <summary>
            Constructor
            </summary>
            <param name="memoryCache"></param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.BaseApiController.GetApplicationStatus">
            <summary>
            GetApplicationStatus
            </summary>
            <returns></returns>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.Api.CancellationPatternsController">
            <summary>
            API Controller demonstrating cancellation token patterns
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.CancellationPatternsController.#ctor(Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Controllers.Api.CancellationPatternsController})">
            <summary>
            Initializes a new instance of the CancellationPatternsController
            </summary>
            <param name="logger">Logger for diagnostic output</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.CancellationPatternsController.NoCancellation(System.Int32)">
             <summary>
             Long-running operation WITHOUT cancellation support
             </summary>
             <param name="iterations">Number of iterations (default: 100)</param>
             <returns>Result after completing all iterations</returns>
             <remarks>
             **Pattern**: Async without cancellation token (anti-pattern)
            
             **What this shows**: A long-running operation that CANNOT be cancelled.
            
             **What can go wrong**:
             - If the user navigates away, the server keeps working
             - Wastes CPU, memory, and connection pool resources
             - In production, this causes scalability issues
            
             **Try it**:
             1. Call with iterations=1000
             2. Cancel the request in your browser/tool
             3. Check server logs - it keeps running!
            
             **Compare with**: `/api/cancellation/with-token` for the correct approach.
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.CancellationPatternsController.WithCancellationToken(System.Int32,System.Threading.CancellationToken)">
             <summary>
             Long-running operation WITH cancellation support
             </summary>
             <param name="iterations">Number of iterations (default: 100)</param>
             <param name="cancellationToken">Cancellation token from HTTP request</param>
             <returns>Result or cancellation response</returns>
             <remarks>
             **Pattern**: Proper cancellation token usage
            
             **What this shows**: How to wire cancellation from HTTP request through to your async operation.
            
             **Key techniques**:
             - Accept `CancellationToken` parameter (ASP.NET Core auto-wires it from HTTP request)
             - Pass it through entire call chain
             - Check `token.IsCancellationRequested` in long loops
             - Return 499 "Client Closed Request" status code
            
             **Try it**:
             1. Call with iterations=1000
             2. Cancel the request quickly
             3. Check logs - operation stops immediately!
            
             **Real-world impact**: Proper cancellation can reduce server load by 30%+ in user-facing APIs.
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.CancellationPatternsController.WithTimeout(System.Int32,System.Int32,System.Threading.CancellationToken)">
             <summary>
             Demonstrates combining timeout and HTTP cancellation tokens
             </summary>
             <param name="iterations">Number of iterations</param>
             <param name="timeoutSeconds">Timeout in seconds (default: 5)</param>
             <param name="cancellationToken">HTTP request cancellation token</param>
             <returns>Result or appropriate error</returns>
             <remarks>
             **Pattern**: Linked cancellation tokens
            
             **What this shows**: How to combine multiple cancellation sources:
             1. HTTP request cancellation (user navigates away)
             2. Timeout cancellation (operation takes too long)
            
             **Key API**: `CancellationTokenSource.CreateLinkedTokenSource()`
            
             **Behavior**:
             - If EITHER source triggers, operation cancels
             - We can distinguish which one triggered by checking individual tokens
             - Returns different status codes: 408 for timeout, 499 for user cancellation
            
             **Try it**:
             - Call with iterations=200, timeoutSeconds=1 to trigger timeout
             - Call with iterations=50, then cancel request to trigger HTTP cancellation
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.CancellationPatternsController.WithCleanup(System.Int32,System.Threading.CancellationToken)">
             <summary>
             Demonstrates cancellation with cleanup (using/finally blocks)
             </summary>
             <param name="iterations">Number of iterations</param>
             <param name="cancellationToken">Cancellation token</param>
             <returns>Result with cleanup information</returns>
             <remarks>
             **Pattern**: Cancellation with resource cleanup
            
             **What this shows**: How to ensure cleanup happens even when operations are cancelled.
            
             **Key techniques**:
             - Use `using` statements for automatic cleanup
             - Put cleanup code in `finally` blocks
             - Cleanup runs whether operation completes, fails, or is cancelled
            
             **Real-world examples**:
             - Closing database connections
             - Releasing file handles
             - Disposing HTTP clients
             - Releasing semaphore slots
            
             **What can go wrong**: Without proper cleanup, cancellation can leak resources (connections, memory, locks).
             </remarks>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.Api.ConcurrencyPatternsController">
            <summary>
            API Controller demonstrating concurrency patterns and parallel execution
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.ConcurrencyPatternsController.#ctor(Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Controllers.Api.ConcurrencyPatternsController})">
            <summary>
            Initializes a new instance of the ConcurrencyPatternsController
            </summary>
            <param name="logger">Logger for diagnostic output</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.ConcurrencyPatternsController.Sequential(System.Int32,System.Int32)">
             <summary>
             Sequential execution - operations run one after another (SLOW)
             </summary>
             <param name="operationCount">Number of operations to perform</param>
             <param name="iterationsPerOperation">Iterations for each operation</param>
             <returns>Results showing sequential execution time</returns>
             <remarks>
             **Pattern**: Sequential async (anti-pattern for independent operations)
            
             **What this shows**: Using `await` in a loop makes operations run sequentially.
            
             **Performance**: For 5 operations taking 1 second each = ~5 seconds total
            
             **When this is OK**: When operations MUST run in order (each depends on previous result)
            
             **When this is BAD**: When operations are independent (like fetching data for different users)
            
             **Compare with**: `/api/concurrency/parallel` to see the performance difference.
            
             **Try it**: Call with operationCount=5 and watch the elapsed time.
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.ConcurrencyPatternsController.Parallel(System.Int32,System.Int32)">
             <summary>
             Parallel execution using Task.WhenAll - operations run concurrently (FAST)
             </summary>
             <param name="operationCount">Number of operations to perform</param>
             <param name="iterationsPerOperation">Iterations for each operation</param>
             <returns>Results showing parallel execution time</returns>
             <remarks>
             **Pattern**: Task.WhenAll for parallel execution
            
             **What this shows**: How to run independent operations concurrently.
            
             **Performance**: For 5 operations taking 1 second each = ~1 second total (5x faster!)
            
             **Key technique**:
             1. Create tasks WITHOUT awaiting them
             2. Collect tasks in a list
             3. Use `Task.WhenAll()` to await all at once
            
             **Real-world use cases**:
             - Fetching data for multiple users
             - Calling multiple microservices
             - Processing multiple files
             - Sending notifications to multiple recipients
            
             **Compare with**: `/api/concurrency/sequential` to see the speedup.
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.ConcurrencyPatternsController.Throttled(System.Int32,System.Int32,System.Int32)">
             <summary>
             Throttled parallel execution using SemaphoreSlim - controlled concurrency
             </summary>
             <param name="operationCount">Number of operations to perform</param>
             <param name="maxConcurrency">Maximum concurrent operations</param>
             <param name="iterationsPerOperation">Iterations for each operation</param>
             <returns>Results showing throttled execution</returns>
             <remarks>
             **Pattern**: SemaphoreSlim for throttling
            
             **What this shows**: How to limit concurrent operations to avoid overwhelming resources.
            
             **Why you need this**:
             - Database connection pools have limits (e.g., 100 connections)
             - External APIs have rate limits (e.g., 10 requests/second)
             - Don't want to exhaust memory/CPU with too many parallel operations
            
             **How it works**:
             - `SemaphoreSlim(maxConcurrency)` acts like a bouncer at a club
             - Only `maxConcurrency` operations run at once
             - When one finishes, the next one starts
            
             **Try it**:
             - Set operationCount=10, maxConcurrency=2
             - You'll see operations complete in waves of 2
            
             **Real-world example**: Preventing connection pool exhaustion when processing large batches.
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.ConcurrencyPatternsController.Comparison(System.Int32,System.Int32,System.Int32)">
             <summary>
             Compare sequential vs parallel vs throttled execution side-by-side
             </summary>
             <param name="operationCount">Number of operations</param>
             <param name="maxConcurrency">Max concurrent for throttled mode</param>
             <param name="iterationsPerOperation">Iterations per operation</param>
             <returns>Comparison of all three approaches</returns>
             <remarks>
             **Pattern**: Performance comparison
            
             **What this shows**: Side-by-side comparison of three approaches to running multiple async operations.
            
             **Expected results** (for 5 operations @ 1s each):
             - Sequential: ~5 seconds (1+1+1+1+1)
             - Parallel: ~1 second (max of all)
             - Throttled (max=2): ~3 seconds (1+1+1 in waves)
            
             **Choosing the right approach**:
             - Sequential: Operations MUST run in order
             - Parallel: Operations are independent AND no resource limits
             - Throttled: Operations are independent BUT must respect resource limits
            
             **Try it**: Experiment with different values to see the tradeoffs.
             </remarks>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.Api.RemoteController">
            <summary>
            Remote Server MOCK - Demonstrates timeout and cancellation patterns
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.RemoteController.#ctor(Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Controllers.Api.RemoteController},Microsoft.Extensions.Caching.Memory.IMemoryCache)">
            <summary>
            Remote Server MOCK - Demonstrates timeout and cancellation patterns
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.RemoteController.MockResultsAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously performs the long-running operation and returns the mock results.
            </summary>
            <param name="loopCount">The loop count.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
            <returns>The mock results.</returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.RemoteController.GetResults(AsyncSpark.Models.MockResults)">
             <summary>
             Mock long-running operation with timeout handling
             </summary>
             <param name="model">Request model with LoopCount and MaxTimeMS</param>
             <returns>Results or timeout response</returns>
             <remarks>
             **Pattern**: Timeout with CancellationTokenSource
            
             **What this shows**: How to set operation-specific timeouts using `CancellationTokenSource(TimeSpan)`.
            
             **Key technique**: Pass `MaxTimeMS` to create a timeout-based cancellation token,
             then wire it through the async operation.
            
             **Returns**:
             - 200: Operation completed within timeout
             - 408: Operation exceeded timeout (Request Timeout)
             - 500: Other errors
            
             **Try it**: Set MaxTimeMS lower than LoopCount to trigger timeout.
             </remarks>
             <response code="200">Request processed successfully.</response>
             <response code="408">Request Timeout.</response>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.Api.StatusController">
            <summary>
            Application Status and Health Endpoints
            </summary>
            <remarks>
            Provides application status and configuration information for monitoring and diagnostics.
            </remarks>
            <param name="configuration"></param>
            <param name="memoryCache"></param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.StatusController.#ctor(Microsoft.Extensions.Configuration.IConfiguration,Microsoft.Extensions.Caching.Memory.IMemoryCache)">
            <summary>
            Application Status and Health Endpoints
            </summary>
            <remarks>
            Provides application status and configuration information for monitoring and diagnostics.
            </remarks>
            <param name="configuration"></param>
            <param name="memoryCache"></param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.StatusController.Get">
            <summary>
            Returns Current Application Status
            </summary>
            <returns></returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.StatusController.GetAppSettings">
            <summary>
            Get App Settings
            </summary>
            <returns></returns>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.Api.WeatherPatternsController">
            <summary>
            Weather API Controller demonstrating async/await patterns
            </summary>
            <remarks>
            This controller provides focused examples of cancellation, timeouts, and resilience patterns
            using real-world weather API scenarios.
            </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.WeatherPatternsController.#ctor(Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Controllers.Api.WeatherPatternsController},OpenWeatherMapClient.Interfaces.IOpenWeatherMapClient,System.Net.Http.IHttpClientFactory)">
            <summary>
            Initializes a new instance of the WeatherPatternsController
            </summary>
            <param name="logger">Logger for diagnostic output</param>
            <param name="weatherService">Weather API client service</param>
            <param name="httpClientFactory">HTTP client factory for making requests</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.WeatherPatternsController.GetWeatherSlow(System.String)">
             <summary>
             Basic async weather call - NO timeout protection
             </summary>
             <param name="location">City name (e.g., "Dallas", "London")</param>
             <returns>Current weather data</returns>
             <remarks>
             **Pattern**: Basic async/await without protection
            
             **What this shows**: A naive async call that could hang indefinitely if the API is slow.
            
             **What can go wrong**: If the weather API takes 5 minutes to respond (or never responds),
             this endpoint will wait forever, tying up server resources.
            
             **Compare with**: `/api/weather/with-timeout` to see the protected version.
            
             **Learning objective**: Always protect external calls with timeouts.
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.WeatherPatternsController.GetWeatherWithTimeout(System.String,System.Int32,System.Threading.CancellationToken)">
             <summary>
             Protected async weather call - WITH timeout and cancellation
             </summary>
             <param name="location">City name (e.g., "Dallas", "London")</param>
             <param name="timeoutSeconds">Timeout in seconds (default: 5)</param>
             <param name="cancellationToken">Cancellation token from HTTP request</param>
             <returns>Current weather data</returns>
             <remarks>
             **Pattern**: Async with timeout and cancellation token
            
             **What this shows**: How to protect an external API call with:
             1. A timeout (fails fast if API is slow)
             2. HTTP request cancellation (stops work if user cancels)
            
             **Key techniques**:
             - `CancellationTokenSource.CreateLinkedTokenSource()` combines HTTP and timeout cancellation
             - If either the user cancels OR timeout expires, the operation stops
             - Returns 408 Request Timeout for timeouts, 499 for user cancellation
            
             **Compare with**: `/api/weather/slow` to see the unprotected version.
            
             **Try it**: Call this endpoint then quickly cancel the request - notice the operation stops immediately.
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.WeatherPatternsController.GetWeatherWithRetry(System.String,System.Int32,System.Threading.CancellationToken)">
             <summary>
             Weather call with Polly retry policy - handles transient failures
             </summary>
             <param name="location">City name (e.g., "Dallas", "London")</param>
             <param name="maxRetries">Maximum retry attempts (default: 3)</param>
             <param name="cancellationToken">Cancellation token</param>
             <returns>Current weather data with retry information</returns>
             <remarks>
             **Pattern**: Resilience with Polly retry policies
            
             **What this shows**: How to handle transient failures (network blips, temporary API errors) by retrying with exponential backoff.
            
             **Key techniques**:
             - Polly retry policy with exponential backoff (1s, 2s, 4s...)
             - Jitter prevents "retry storms" when many clients retry simultaneously
             - Context tracks retry count for observability
            
             **When to use**: Any call to external services that might have transient failures.
            
             **What can go wrong**: Without retries, temporary network issues become permanent failures for your users.
            
             **Try it**: The response includes `retryCount` so you can see if retries occurred.
             </remarks>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.Api.WeatherPatternsController.GetMultipleCitiesWeather(System.String,System.Threading.CancellationToken)">
             <summary>
             Fetch weather for multiple cities concurrently using Task.WhenAll
             </summary>
             <param name="locations">Comma-separated city names (e.g., "Dallas,London,Tokyo")</param>
             <param name="cancellationToken">Cancellation token</param>
             <returns>Weather data for all cities</returns>
             <remarks>
             **Pattern**: Concurrent async operations with Task.WhenAll
            
             **What this shows**: How to fetch data for multiple cities in parallel instead of sequentially.
            
             **Key difference**:
             - ❌ BAD: `foreach` loop with `await` inside = sequential (slow)
             - ✅ GOOD: `Task.WhenAll` = parallel (fast)
            
             **Performance impact**: For 3 cities with 1s API calls each:
             - Sequential: ~3 seconds total
             - Parallel: ~1 second total
            
             **What can go wrong**: If one city fails, `Task.WhenAll` throws. Consider using continuation-based error handling for partial success scenarios.
            
             **Try it**: Request weather for 5+ cities and compare response time to sequential calls.
             </remarks>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.BaseController">
            <summary>
            BaseController - Refactored to follow DI best practices
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Controllers.BaseController._logger">
            <summary>
            Logger for base controller
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Controllers.BaseController._httpClientFactory">
            <summary>
            HTTP Client Factory for creating HTTP clients
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Controllers.BaseController._httpWeatherPolicy">
            <summary>
            Weather Policy
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Controllers.BaseController.jitter">
            <summary>
            Shared Jitter for retry policies
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.BaseController.#ctor(Microsoft.Extensions.Logging.ILogger,System.Net.Http.IHttpClientFactory)">
            <summary>
            Base Controller Constructor
            </summary>
            <param name="logger">Logger instance</param>
            <param name="httpClientFactory">HTTP client factory</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.BaseController.CreateHttpClient">
            <summary>
            Creates a properly configured HTTP client
            </summary>
            <returns>HttpClient instance</returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.BaseController.CreateCancellationTokenSource(System.Nullable{System.TimeSpan})">
            <summary>
            Creates a cancellation token source with the specified timeout
            </summary>
            <param name="timeout">Timeout duration</param>
            <returns>CancellationTokenSource</returns>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.BulkCallsController">
            <summary>
            Controller for handling bulk HTTP GET calls.
            </summary>
            <remarks>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Controllers.BulkCallsController"/> class.
            </remarks>
            <param name="logger">The logger.</param>
            <param name="getCallService">The HTTP GET call service.</param>
            <param name="httpClientFactory">The HTTP client factory.</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.BulkCallsController.#ctor(Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Controllers.BulkCallsController},AsyncSpark.HttpGetCall.IHttpGetCallService,System.Net.Http.IHttpClientFactory)">
            <summary>
            Controller for handling bulk HTTP GET calls.
            </summary>
            <remarks>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Controllers.BulkCallsController"/> class.
            </remarks>
            <param name="logger">The logger.</param>
            <param name="getCallService">The HTTP GET call service.</param>
            <param name="httpClientFactory">The HTTP client factory.</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.BulkCallsController.CallEndpointMultipleTimes(System.Int32,System.Int32,System.String)">
            <summary>
            Calls the specified endpoint multiple times asynchronously.
            </summary>
            <param name="maxThreads">The maximum number of concurrent threads.</param>
            <param name="iterationCount">The number of iterations.</param>
            <param name="endpoint">The endpoint URL.</param>
            <returns>A list of HTTP GET call results.</returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.BulkCallsController.Index">
            <summary>
            Action method for the index page.
            </summary>
            <returns>The index view with the results of the bulk HTTP GET calls.</returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.BulkCallsController.Create">
            <summary>
            Action method for creating a new bulk call test.
            </summary>
            <returns>The create view.</returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.BulkCallsController.Create(System.Int32,System.Int32,System.String)">
            <summary>
            Action method for handling the form submission to create a new bulk call test.
            </summary>
            <param name="maxThreads">The maximum number of concurrent threads.</param>
            <param name="iterationCount">The number of iterations.</param>
            <param name="endpoint">The endpoint URL.</param>
            <returns>Redirects to the index view with the results of the bulk HTTP GET calls.</returns>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.HomeController">
            <summary>
            Home Controller
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.HomeController.#ctor(Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Controllers.HomeController})">
            <summary>
            Constructor for HomeController
            </summary>
            <param name="logger">Logger instance</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.HomeController.Error">
            <summary>
            Error
            </summary>
            <returns></returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.HomeController.Index">
            <summary>
            Home Page
            </summary>
            <returns></returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.HomeController.ThemeDemo">
            <summary>
            Bootstrap 5 Theme Demo - Kitchen Sink
            </summary>
            <returns>View displaying all Bootstrap 5 components and styles</returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.HomeController.Learn">
            <summary>
            Learn Async/Await - Educational landing page
            </summary>
            <returns>View with structured learning modules and paths</returns>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.HomeController.WebSpark">
            <summary>
            WebSpark NuGet Packages - Information and promotion page
            </summary>
            <returns>View showcasing WebSpark.Bootswatch and WebSpark.HttpClientUtility</returns>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.OpenWeatherController">
            <summary>
            OpenWeather Controller for weather data management
            </summary>
            <remarks>
            Initializes a new instance of the OpenWeatherController
            </remarks>
            <param name="logger">Logger for OpenWeatherController</param>
            <param name="weatherService">Weather service instance</param>
            <param name="cache">Memory cache instance</param>
            <param name="httpClientFactory">HTTP client factory</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.OpenWeatherController.#ctor(Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Controllers.OpenWeatherController},OpenWeatherMapClient.Interfaces.IOpenWeatherMapClient,Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Net.Http.IHttpClientFactory)">
            <summary>
            OpenWeather Controller for weather data management
            </summary>
            <remarks>
            Initializes a new instance of the OpenWeatherController
            </remarks>
            <param name="logger">Logger for OpenWeatherController</param>
            <param name="weatherService">Weather service instance</param>
            <param name="cache">Memory cache instance</param>
            <param name="httpClientFactory">HTTP client factory</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.OpenWeatherController.Index(System.String)">
            <summary>
            Index action for weather display
            </summary>
            <param name="location">Location to get weather for</param>
            <returns>View with weather data</returns>
        </member>
        <member name="T:AsyncSpark.Web.Controllers.PollyController">
            <summary>
            Controller for demonstrating the use of Polly for handling retries in HTTP requests.
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.PollyController.#ctor(Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Controllers.PollyController},System.Net.Http.IHttpClientFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Controllers.PollyController"/> class.
            </summary>
            <param name="logger">The logger instance for logging information.</param>
            <param name="clientFactory">The HTTP client factory for creating HTTP clients.</param>
        </member>
        <member name="M:AsyncSpark.Web.Controllers.PollyController.Index(System.Int32,System.Int32)">
            <summary>
            Handles the GET request to the home page. Executes an HTTP POST request with retry logic.
            </summary>
            <param name="loopCount">The number of iterations to perform in the mock operation.</param>
            <param name="maxTimeMs">The maximum time allowed for the operation, in milliseconds.</param>
            <returns>Returns the result of the operation.</returns>
        </member>
        <member name="T:AsyncSpark.Web.Extensions.ConfigurationExtensions">
            <summary>
            ConfigurationExtensions
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Extensions.ConfigurationExtensions.GetInt(Microsoft.Extensions.Configuration.IConfiguration,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="_config"></param>
            <param name="configKey"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:AsyncSpark.Web.Extensions.ConfigurationExtensions.GetIntList(Microsoft.Extensions.Configuration.IConfiguration,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="_config"></param>
            <param name="configKey"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:AsyncSpark.Web.Extensions.ConfigurationExtensions.GetString(Microsoft.Extensions.Configuration.IConfiguration,System.String,System.String)">
            <summary>
            Get String from Configuration
            </summary>
            <param name="_config"></param>
            <param name="configKey"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:AsyncSpark.Web.Extensions.ConfigurationExtensions.GetStringList(Microsoft.Extensions.Configuration.IConfiguration,System.String,System.String)">
            <summary>
            Get a List of string from Configuration
            </summary>
            <param name="_config"></param>
            <param name="configKey"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="T:AsyncSpark.Web.Extensions.CustomScalarExtensions">
            <summary>
            Custom OpenAPI configuration using built-in .NET OpenAPI + Scalar UI
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Extensions.CustomScalarExtensions.AddCustomScalar(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Adds OpenAPI documentation generation
            </summary>
            <param name="services"></param>
            <returns></returns>
        </member>
        <member name="M:AsyncSpark.Web.Extensions.CustomScalarExtensions.UseCustomScalar(Microsoft.AspNetCore.Builder.WebApplication)">
            <summary>
            Configures the application to use OpenAPI and Scalar UI
            </summary>
            <param name="app">The web application</param>
            <returns>The web application with Scalar configured</returns>
        </member>
        <member name="T:AsyncSpark.Web.Extensions.HttpContextExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Extensions.HttpContextExtensions.AddHttpContextAccessor(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            
            </summary>
            <param name="services"></param>
        </member>
        <member name="M:AsyncSpark.Web.Extensions.HttpContextExtensions.UseHttpContext(Microsoft.AspNetCore.Builder.IApplicationBuilder)">
            <summary>
            
            </summary>
            <param name="app"></param>
            <returns></returns>
        </member>
        <member name="T:AsyncSpark.Web.Extensions.MyHttpContext">
            <summary>
            
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Extensions.MyHttpContext.Current">
            <summary>
            Gets the current HttpContext
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Extensions.MyHttpContext.AppBaseUrl">
            <summary>
            Gets the application base URL
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Middleware.EncodingMiddleware">
            <summary>
            Middleware to ensure proper UTF-8 encoding for all responses
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Middleware.EncodingMiddleware.#ctor(Microsoft.AspNetCore.Http.RequestDelegate,Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Middleware.EncodingMiddleware})">
            <summary>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Middleware.EncodingMiddleware"/> class
            </summary>
            <param name="next">The next middleware in the pipeline</param>
            <param name="logger">The logger instance</param>
        </member>
        <member name="M:AsyncSpark.Web.Middleware.EncodingMiddleware.InvokeAsync(Microsoft.AspNetCore.Http.HttpContext)">
            <summary>
            Processes an HTTP request and ensures UTF-8 encoding
            </summary>
            <param name="context">The HTTP context for the current request</param>
            <returns>A task representing the asynchronous operation</returns>
        </member>
        <member name="T:AsyncSpark.Web.Middleware.EncodingMiddlewareExtensions">
            <summary>
            Extension methods for registering the encoding middleware
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Middleware.EncodingMiddlewareExtensions.UseEncodingMiddleware(Microsoft.AspNetCore.Builder.IApplicationBuilder)">
            <summary>
            Adds encoding middleware to the pipeline
            </summary>
            <param name="builder">The application builder</param>
            <returns>The application builder</returns>
        </member>
        <member name="T:AsyncSpark.Web.Middleware.RequestLoggingMiddleware">
            <summary>
            Middleware for logging HTTP requests and responses
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Middleware.RequestLoggingMiddleware.#ctor(Microsoft.AspNetCore.Http.RequestDelegate,Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Middleware.RequestLoggingMiddleware})">
            <summary>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Middleware.RequestLoggingMiddleware"/> class
            </summary>
            <param name="next">The next middleware in the pipeline</param>
            <param name="logger">The logger instance</param>
        </member>
        <member name="M:AsyncSpark.Web.Middleware.RequestLoggingMiddleware.InvokeAsync(Microsoft.AspNetCore.Http.HttpContext)">
            <summary>
            Processes an HTTP request and logs request/response information
            </summary>
            <param name="context">The HTTP context for the current request</param>
            <returns>A task representing the asynchronous operation</returns>
        </member>
        <member name="T:AsyncSpark.Web.Middleware.RequestLoggingMiddlewareExtensions">
            <summary>
            Extension methods for registering the request logging middleware
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Middleware.RequestLoggingMiddlewareExtensions.UseRequestLogging(Microsoft.AspNetCore.Builder.IApplicationBuilder)">
            <summary>
            Adds request logging middleware to the pipeline
            </summary>
            <param name="builder">The application builder</param>
            <returns>The application builder</returns>
        </member>
        <member name="T:AsyncSpark.Web.Models.ApplicationStatus">
            <summary>
            ApplicationStatus
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Models.ApplicationStatus.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Models.ApplicationStatus.#ctor(System.Reflection.Assembly)">
            <summary>
            
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="P:AsyncSpark.Web.Models.ApplicationStatus.BuildDate">
            <summary>
            
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ApplicationStatus.BuildVersion">
            <summary>
            BuildVersion
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ApplicationStatus.Features">
            <summary>
            Features
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ApplicationStatus.Messages">
            <summary>
            Messages
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ApplicationStatus.Region">
            <summary>
            Region
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ApplicationStatus.Status">
            <summary>
            Status 
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ApplicationStatus.Tests">
            <summary>
            Tests 
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Models.BuildVersion">
            <summary>
            Build Version
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Models.BuildVersion.#ctor(System.Reflection.Assembly)">
            <summary>
            Build Version
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:AsyncSpark.Web.Models.BuildVersion.ToString">
            <summary>
            Override the To String Function to Format Version
            </summary>
            <returns></returns>
        </member>
        <member name="P:AsyncSpark.Web.Models.BuildVersion.MajorVersion">
            <summary>
            Major Version
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.BuildVersion.MinorVersion">
            <summary>
            Minor Version
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.BuildVersion.Build">
            <summary>
            Build
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.BuildVersion.Revision">
            <summary>
            Revision
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Models.ErrorResource">
            <summary>
            Error Resource
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Models.ErrorResource.#ctor(System.Collections.Generic.List{System.String})">
             <summary>
            
             </summary>
             <param name="messages"></param>
        </member>
        <member name="M:AsyncSpark.Web.Models.ErrorResource.#ctor(System.String)">
            <summary>
            Error Resource
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:AsyncSpark.Web.Models.ErrorResource.Messages">
            <summary>
            Messages
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ErrorResource.Success">
            <summary>
            Success
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Models.ErrorViewModel">
            <summary>
            
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ErrorViewModel.RequestId">
            <summary>
            
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.ErrorViewModel.ShowRequestId">
            <summary>
            
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Models.KeyVaultOptions">
            <summary>
            Represents the options for accessing Azure Key Vault.
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.KeyVaultOptions.Mode">
            <summary>
            Gets or sets the mode of accessing Azure Key Vault.
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.KeyVaultOptions.KeyVaultUri">
            <summary>
            Gets or sets the URI of the Azure Key Vault.
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.KeyVaultOptions.ClientId">
            <summary>
            Gets or sets the client ID for authenticating with Azure Key Vault.
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Models.KeyVaultOptions.ClientSecret">
            <summary>
            Gets or sets the client secret for authenticating with Azure Key Vault.
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Models.KeyVaultOptions.#ctor(AsyncSpark.Web.Models.KeyVaultUsage,System.String,System.String,System.String)">
            <summary>
            Initialize KeyVaultOptions.
            </summary>
            <param name="mode"></param>
            <param name="keyVaultUri"></param>
            <param name="clientId"></param>
            <param name="clientSecret"></param>
        </member>
        <member name="T:AsyncSpark.Web.Models.KeyVaultUsage">
            <summary>
            Key Vault Usage
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Models.KeyVaultUsage.UseLocalSecretStore">
            <summary>
            Use local secret store
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Models.KeyVaultUsage.UseClientSecret">
            <summary>
            Use client secret
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Models.KeyVaultUsage.UseMsi">
            <summary>
            Use Managed Service Identity (MSI)
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Models.ServiceStatus">
            <summary>
            Service Status Values
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Models.ServiceStatus.Degraded">
            <summary>
            Some sub-set of the system is not working
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Models.ServiceStatus.Offline">
            <summary>
            The system is not available
            </summary>
        </member>
        <member name="F:AsyncSpark.Web.Models.ServiceStatus.Online">
            <summary>
            The system is fully online 
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Services.ConfigurationHealthCheck">
            <summary>
            Health check for configuration validation
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Services.ConfigurationHealthCheck.#ctor(AsyncSpark.Web.Services.IConfigurationValidationService)">
            <summary>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Services.ConfigurationHealthCheck"/> class
            </summary>
            <param name="configValidationService">The configuration validation service</param>
        </member>
        <member name="M:AsyncSpark.Web.Services.ConfigurationHealthCheck.CheckHealthAsync(Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext,System.Threading.CancellationToken)">
            <summary>
            Checks the health of the application configuration
            </summary>
            <param name="context">The health check context</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>A task representing the health check result</returns>
        </member>
        <member name="T:AsyncSpark.Web.Services.IConfigurationValidationService">
            <summary>
            Service for validating application configuration
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Services.IConfigurationValidationService.ValidateConfiguration">
            <summary>
            Validates the application configuration
            </summary>
            <returns>Validation result</returns>
        </member>
        <member name="T:AsyncSpark.Web.Services.ConfigurationValidationResult">
            <summary>
            Configuration validation result
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Services.ConfigurationValidationResult.IsValid">
            <summary>
            Gets or sets a value indicating whether the configuration is valid
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Services.ConfigurationValidationResult.Errors">
            <summary>
            Gets or sets the list of configuration errors
            </summary>
        </member>
        <member name="P:AsyncSpark.Web.Services.ConfigurationValidationResult.Warnings">
            <summary>
            Gets or sets the list of configuration warnings
            </summary>
        </member>
        <member name="T:AsyncSpark.Web.Services.ConfigurationValidationService">
            <summary>
            Implementation of configuration validation service
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Services.ConfigurationValidationService.#ctor(Microsoft.Extensions.Configuration.IConfiguration,Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Services.ConfigurationValidationService})">
            <summary>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Services.ConfigurationValidationService"/> class
            </summary>
            <param name="configuration">The application configuration</param>
            <param name="logger">The logger instance</param>
        </member>
        <member name="M:AsyncSpark.Web.Services.ConfigurationValidationService.ValidateConfiguration">
            <summary>
            Validates the application configuration and returns validation results
            </summary>
            <returns>A <see cref="T:AsyncSpark.Web.Services.ConfigurationValidationResult"/> containing validation results</returns>
        </member>
        <member name="T:AsyncSpark.Web.Services.IStartupService">
            <summary>
            Service that runs during application startup to perform initialization tasks
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Services.IStartupService.ExecuteAsync(System.Threading.CancellationToken)">
            <summary>
            Executes startup tasks
            </summary>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Task representing the startup operation</returns>
        </member>
        <member name="T:AsyncSpark.Web.Services.StartupService">
            <summary>
            Implementation of startup service
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Services.StartupService.#ctor(AsyncSpark.Web.Services.IConfigurationValidationService,Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Services.StartupService},Microsoft.Extensions.Caching.Memory.IMemoryCache)">
            <summary>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Services.StartupService"/> class
            </summary>
            <param name="configValidationService">The configuration validation service</param>
            <param name="logger">The logger instance</param>
            <param name="memoryCache">The memory cache instance</param>
        </member>
        <member name="M:AsyncSpark.Web.Services.StartupService.ExecuteAsync(System.Threading.CancellationToken)">
            <summary>
            Executes startup tasks including configuration validation and cache pre-warming
            </summary>
            <param name="cancellationToken">Cancellation token for the async operation</param>
            <returns>A task representing the asynchronous startup operation</returns>
        </member>
        <member name="T:AsyncSpark.Web.Services.StartupHostedService">
            <summary>
            Hosted service that runs the startup service
            </summary>
        </member>
        <member name="M:AsyncSpark.Web.Services.StartupHostedService.#ctor(System.IServiceProvider,Microsoft.Extensions.Logging.ILogger{AsyncSpark.Web.Services.StartupHostedService})">
            <summary>
            Initializes a new instance of the <see cref="T:AsyncSpark.Web.Services.StartupHostedService"/> class
            </summary>
            <param name="serviceProvider">The service provider for resolving dependencies</param>
            <param name="logger">The logger instance</param>
        </member>
        <member name="M:AsyncSpark.Web.Services.StartupHostedService.StartAsync(System.Threading.CancellationToken)">
            <summary>
            Triggered when the application host is ready to start the service
            </summary>
            <param name="cancellationToken">Cancellation token for the async operation</param>
            <returns>A task representing the asynchronous start operation</returns>
        </member>
        <member name="M:AsyncSpark.Web.Services.StartupHostedService.StopAsync(System.Threading.CancellationToken)">
            <summary>
            Triggered when the application host is performing a graceful shutdown
            </summary>
            <param name="cancellationToken">Cancellation token for the async operation</param>
            <returns>A task representing the asynchronous stop operation</returns>
        </member>
        <member name="T:Program">
            <summary>
            Auto-generated public partial Program class for top-level statement apps.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.OpenApi.Generated.DocumentationCommentIdHelper.CreateDocumentationId(System.Type)">
            <summary>
            Generates a documentation comment ID for a type.
            Example: T:Namespace.Outer+Inner`1 becomes T:Namespace.Outer.Inner`1
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.OpenApi.Generated.DocumentationCommentIdHelper.CreateDocumentationId(System.Reflection.PropertyInfo)">
            <summary>
            Generates a documentation comment ID for a property.
            Example: P:Namespace.ContainingType.PropertyName or for an indexer P:Namespace.ContainingType.Item(System.Int32)
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.OpenApi.Generated.DocumentationCommentIdHelper.CreateDocumentationId(System.Type,System.String)">
            <summary>
            Generates a documentation comment ID for a property given its container type and property name.
            Example: P:Namespace.ContainingType.PropertyName
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.OpenApi.Generated.DocumentationCommentIdHelper.CreateDocumentationId(System.Reflection.MethodInfo)">
            <summary>
            Generates a documentation comment ID for a method (or constructor).
            For example:
              M:Namespace.ContainingType.MethodName(ParamType1,ParamType2)~ReturnType
              M:Namespace.ContainingType.#ctor(ParamType)
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.OpenApi.Generated.DocumentationCommentIdHelper.GetTypeDocId(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Generates a documentation ID string for a type.
            This method handles nested types (replacing '+' with '.'),
            generic types, arrays, pointers, by-ref types, and generic parameters.
            The <paramref name="includeGenericArguments"/> flag controls whether
            constructed generic type arguments are emitted, while <paramref name="omitGenericArity"/>
            controls whether the generic arity marker (e.g. "`1") is appended.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.OpenApi.Generated.DocumentationCommentIdHelper.NormalizeDocId(System.String)">
            <summary>
            Normalizes a documentation comment ID to match the compiler-style format.
            Strips the return type suffix for ordinary methods but retains it for conversion operators.
            </summary>
            <param name="docId">The documentation comment ID to normalize.</param>
            <returns>The normalized documentation comment ID.</returns>
        </member>
    </members>
</doc>
